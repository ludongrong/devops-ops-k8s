= kubernetes
Author 卢冬榕
:doctype: article
:encoding: utf-8
:lang: en
:toc: left
:numbered:


= kubernetes

== `kubernetes` 是什么？

Kubernetes, also known as K8s, is an open-source system for automating deployment, scaling, and management of containerized applications.

image::./README/components-of-kubernetes.png[align="center"]

[NOTE]
====
https://kubernetes.io
====

- 代码托管 - https://github.com/kubernetes/kubernetes

- 社区 - https://github.com/kubernetes/community

=== `kubernetes` 具备哪些解决能力？

- Service discovery and load balancing（服务发现和负载均衡）
- Storage orchestration（存储编排）

[NOTE]
====
https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/
====

=== `kubernetes` 的组件

- Control 组件

kube-apiserver、etcd、kube-scheduler、kube-controller-manager、cloud-controller-manager

- Node 组件

kubelet、kube-proxy、Container Runtime

- 插件

DNS、Dashboard

image::./README/kubernetes-components.png[align="center"]

[NOTE]
====
https://kubernetes.io/docs/concepts/overview/components/
====

==== `kubernetes` 的 `kube-apiserver`

`kube-apiserver` 提供集群管理的REST API接口，包括认证授权、数据校验以及集群状态变更等。

. 只有 `API Server` 才直接操作 `etcd`
. 其他模块通过 `API Server` 查询或修改数据
. 提供其他模块之间的数据交互和通信的枢纽

==== `kubernetes` 的 `kube-controller-manager`

`kube-controller-manager` 由一系列的控制器组成，它通过apiserver监控整个集群的状态，并确保集群处于预期的工作状态。

==== `kubernetes` 的 `kube-scheduler`

`kube-scheduler` 负责分配调度 `Pod` 到集群内的 `node` 节点。

. 监听 `kube-apiserver`，查询还未分配 `Node` 的 `Pod`
. 根据调度策略为这些 `Pod` 分配节点

==== `kubernetes` 的 `kube-proxy`

`kube-proxy` 负责发布应用服务与负载均衡

==== `kubernetes` 的 `kubelet`

`kubelet` 在每个 `Node` 上都会启动一个 `kubelet` 服务进程。`kubelet` 作为连接 `Kubernetes Master` 和各 `Node` 之间的桥梁，用于处理 `Master` 下发到本节点的任务，管理 `Pod` 及 `Pod` 中的容器。每个 `kubelet` 进程都会在 `api-server` 上注册本节点自身的信息，定期向 `Master` 汇报节点资源的使用情况，`Node` 和 `Pod` 的CPU和内存使用数据由 `Metrics Server` 提供，其他指标由 `Prometheus` 采集和存储。

==== `Traditional deployment` 跟 `Container deployment` 的差异

image::./README/container_evolution.png[align="center"]

[NOTE]
====
https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/
====

=== `kubernetes` 的 `CRI`

`CRI` 是 Container Runtime Interface 的缩写。凡是支持CRI的容器运行时，皆可作为K8S的底层容器运行时。

image::./README/2021-05-04_11-47-02.png[align="center"]

如果你使用containerd作为K8S容器运行时的话，由于containerd内置了 CRI 插件，kubelet可以直接调用containerd。

image::./README/2021-05-04_11-47-03.png[align="center"]

==== 为什么弃用 `k8s+docker`？

如果你使用Docker作为K8S容器运行时的话，kubelet需要先要通过 dockershim 去调用Docker，再通过Docker去调用containerd。

==== `kubernetes` 的 `k8s+containerd`

image::./README/2021-05-04_11-48-59.png[align="center"]

==== `kubernetes` 的 `k8s+cri-o`

image::./README/2021-05-04_11-47-01.png[align="center"]

== 搭建 `k8s+containerd` 环境

- `ansible` 方式 - https://faun.pub/how-to-create-your-own-kubernetes-cluster-using-ansible-7c6b5c031a5d

=== 下载 `kubernetes`

==== 编译方式

[source,sh]
----
git clone https://github.com/kubernetes/kubernetes
cd kubernetes
make
----

You have a working Docker environment.

[source,sh]
----
git clone https://github.com/kubernetes/kubernetes
cd kubernetes
make quick-release
----

==== 下载现成

image::./README/2021-05-04_11-47-04.png[align="center"]

=== 安装 `etcd`

https://github.com/ludongrong/devops/tree/main/41-%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83

=== 安装 `containerd`

==== 修改 `/etc/containerd/config.toml`

- containerd/cri - https://github.com/containerd/cri/blob/release/1.4/docs/registry.md

- containerd/containerd - https://github.com/containerd/containerd/blob/master/docs/cri/config.md

===== 配置 `http` 协议注册端 - Registry Endpoint

注册端 -> 拉取镜像的服务器。

[source,toml]
----
version = 2
root = "${CONTAINERD_DIR}/root"
state = "${CONTAINERD_DIR}/state"

[plugins]
  [plugins."io.containerd.grpc.v1.cri"]
	sandbox_image = "gcr.io/google-containers/pause:3.2" <1>
    [plugins."io.containerd.grpc.v1.cri".cni]
      bin_dir = "/opt/k8s/bin"
      conf_dir = "/etc/cni/net.d"
  [plugins."io.containerd.grpc.v1.cri".registry]
    [plugins."io.containerd.grpc.v1.cri".registry.mirrors]
      [plugins."io.containerd.grpc.v1.cri".registry.mirrors."docker.io"]
        endpoint = ["http://192.168.41.32:8083"]
	  [plugins."io.containerd.grpc.v1.cri".registry.mirrors."gcr.io"]
	    endpoint = ["http://192.168.41.32:8083"]
	  [plugins."io.containerd.grpc.v1.cri".registry.mirrors."k8s.gcr.io"]
	    endpoint = ["http://192.168.41.32:8083"]
	  [plugins."io.containerd.grpc.v1.cri".registry.mirrors."quay.io"]
	    endpoint = ["http://192.168.41.32:8083"]
    [plugins."io.containerd.grpc.v1.cri".registry.configs]
      [plugins."io.containerd.grpc.v1.cri".registry.configs."docker.io".tls]
        insecure_skip_verify = true
	  [plugins."io.containerd.grpc.v1.cri".registry.configs."gcr.io".tls]
        insecure_skip_verify = true
	  [plugins."io.containerd.grpc.v1.cri".registry.configs."k8s.gcr.io".tls]
        insecure_skip_verify = true
	  [plugins."io.containerd.grpc.v1.cri".registry.configs."quay.io".tls]
        insecure_skip_verify = true
  [plugins."io.containerd.runtime.v1.linux"]
    shim = "containerd-shim"
    runtime = "runc"
    runtime_root = ""
    no_shim = false
    shim_debug = false
----

<1> 国内镜像 registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.2

===== 配置 `https` 协议注册端 - Registry TLS Communication

注册端 -> 拉取镜像的服务器。

**遗留问题**，配置了 `tls` 还是报 x509: certificate signed by unknown authority。

[NOTE]
====
引用 - https://blog.csdn.net/y_chen_007/article/details/97525206
====

[source,toml]
----
version = 2
root = "${CONTAINERD_DIR}/root"
state = "${CONTAINERD_DIR}/state"

[plugins]
  [plugins."io.containerd.grpc.v1.cri"]
	sandbox_image = "gcr.io/google-containers/pause:3.2"
    [plugins."io.containerd.grpc.v1.cri".cni]
      bin_dir = "/opt/k8s/bin"
      conf_dir = "/etc/cni/net.d"
  [plugins."io.containerd.grpc.v1.cri".registry]
    [plugins."io.containerd.grpc.v1.cri".registry.mirrors]
      [plugins."io.containerd.grpc.v1.cri".registry.mirrors."docker.io"]
        endpoint = ["https://192.168.41.32:8082"]
	  [plugins."io.containerd.grpc.v1.cri".registry.mirrors."gcr.io"]
	    endpoint = ["https://192.168.41.32:8082"]
    [plugins."io.containerd.grpc.v1.cri".registry.configs]
      [plugins."io.containerd.grpc.v1.cri".registry.configs."docker.io".tls]
        ca_file   = "ca.pem"
        cert_file = "n5.pem"
        key_file  = "n5-key.pem"
	  [plugins."io.containerd.grpc.v1.cri".registry.configs."gcr.io".tls]
        ca_file   = "ca.pem"
        cert_file = "n5.pem"
        key_file  = "n5-key.pem"
  [plugins."io.containerd.runtime.v1.linux"]
    shim = "containerd-shim"
    runtime = "runc"
    runtime_root = ""
    no_shim = false
    shim_debug = false
----

==== 升级 `containerd`

[source,sh]
----
cd /opt/k8s/work

wget https://github.com/containerd/containerd/releases/download/v1.5.0/containerd-1.5.0-linux-amd64.tar.gz

mkdir containerd-1.5.0
tar -xvf containerd-1.3.3.linux-amd64.tar.gz -C containerd-1.5.0

for node_ip in ${NODE_IPS[@]}
  do
    echo ">>> ${node_ip}"
    scp containerd-1.5.0/bin/* root@${node_ip}:/opt/k8s/bin
    ssh root@${node_ip} "chmod a+x /opt/k8s/bin/* && mkdir -p /etc/cni/net.d"
  done
----

=== 安装 `calicoctl`

https://www.kancloud.cn/willfeng/k8s/654128

- https://github.com/projectcalico/calico

- https://docs.projectcalico.org/about/about-calico

==== `kubernetes` 方式安装

https://docs.projectcalico.org/getting-started/kubernetes/flannel/flannel

==== `etc` 方式安装

https://docs.projectcalico.org/getting-started/calicoctl/configure/etcd

[source,sh]
----
cd /opt/k8s/work
curl -O -L  https://github.com/projectcalico/calicoctl/releases/download/v3.12.0/calicoctl
mv calicoctl ../bin
chmod +x /opt/k8s/bin/calicoctl
----

配置

[source,sh]
----
cd /opt/k8s/work
source /opt/k8s/bin/environment.sh
cat > calicoctl.cfg <<EOF
apiVersion: projectcalico.org/v3
kind: CalicoAPIConfig
metadata:
spec:
  etcdEndpoints: ${ETCD_ENDPOINTS}
  etcdKeyFile: /etc/calico/key.pem
  etcdCertFile: /etc/calico/cert.pem
  etcdCACertFile: /etc/calico/ca.pem
EOF
----

查看

[source,sh]
----
# 查看所有calico节点状态
calicoctl node status
calicoctl get nodes
calicoctl get ippool
# 查看集群ipPool情况
calicoctl get ipPool -o yaml

kubectl get pods -n kube-system -owide
----

[source,sh]
----
cd /opt/k8s/work
source /opt/k8s/bin/environment.sh
for node_ip in ${NODE_IPS[@]}
  do
    echo ">>> ${node_ip}"
    ssh root@${node_ip} "systemctl status etcd|grep Active"
  done
----

==== 问题 - BGP not established with...

- 问题

Readiness probe failed: caliconode is not ready: BIRD is not ready: BGP not established with 10.117.

[NOTE]
====
取日志命令 -> kubectl describe pods calico-node-hzsff -n kube-system
====

- 解决方法

调整calicao 网络插件的网卡发现机制。在 `calico.yaml` 文件添加以下二行。

[source,text]
----
- name: IP_AUTODETECTION_METHOD
    value: "interface=ens.*"  <1>
----

<1> ens 根据实际网卡开头配置

- 引用

https://blog.csdn.net/u011327801/article/details/100579803

==== 升级 `calico`

[source,sh]
----
cd /opt/k8s/work

wget https://github.com/projectcalico/calico/releases/download/v3.12.0/release-v3.12.0.tgz

tar -xvf release-v3.12.0.tgz
----

== 维护 `kubernetes` 环境

=== 通过 `kubectl` 查看日志

[source,sh]
----
kubectl describe pod kubernetes-dashboard-849cd79b75-s2snt --namespace kube-system
kubectl logs -f pods/monitoring-influxdb-fc8f8d5cd-dbs7d -n kube-system
kubectl logs --tail 200 -f kube-apiserver -n kube-system |more
kubectl logs --tail 200 -f podname -n jenkins
----

[NOTE]
====
使用Kubelet describe 查看日志，一定要带上 命名空间，否则会报如下错误。如：kubectl describe pod coredns-6c65fc5cbb-8ntpv。报错 Error from server (NotFound): pods "coredns-6c65fc5cbb-8ntpv" not found。
====

=== 通过 `journalctl` 查看日志

[source,sh]
----
journalctl -u kube-scheduler
journalctl -xefu kubelet
journalctl -u kube-apiserver
journalctl -u kubelet |tail
journalctl -xe
----

=== 通过 `系统` 查看日志

[source,sh]
----
cat /var/log/messages
----